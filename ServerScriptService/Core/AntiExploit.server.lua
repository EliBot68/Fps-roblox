-- AntiExploit.server.lua
-- Enterprise-grade anti-exploit system with automated threat response
-- Integrates with SecurityValidator and Service Locator pattern

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")

-- Import dependencies (will be injected via Service Locator)
local SecurityValidator = require(ReplicatedStorage.Shared.SecurityValidator)
local Logging = require(ReplicatedStorage.Shared.Logging)

local AntiExploit = {}
AntiExploit.__index = AntiExploit

-- Type definitions
export type BanRecord = {
	userId: number,
	username: string,
	reason: string,
	banDate: number,
	banLength: number?, -- nil for permanent ban
	evidence: {[string]: any},
	adminUserId: number?
}

export type SuspiciousActivity = {
	userId: number,
	activityType: string,
	timestamp: number,
	severity: number,
	details: {[string]: any}
}

-- Enterprise configuration
local ANTI_EXPLOIT_CONFIG = {
	-- Ban durations by severity (in hours)
	banDurations = {
		FIRST_OFFENSE = 24,      -- 1 day
		SECOND_OFFENSE = 168,    -- 1 week  
		THIRD_OFFENSE = 720,     -- 1 month
		PERMANENT = nil          -- Permanent ban
	},
	
	-- Auto-ban thresholds
	autoBanThresholds = {
		CRITICAL_THREAT_COUNT = 3,    -- 3 critical threats = auto ban
		HIGH_THREAT_COUNT = 5,        -- 5 high threats = auto ban
		MEDIUM_THREAT_COUNT = 10      -- 10 medium threats = auto ban
	},
	
	-- Monitoring intervals
	monitoringIntervals = {
		threatAssessment = 30,        -- Check threats every 30 seconds
		banDataSync = 300,            -- Sync ban data every 5 minutes
		performanceMonitoring = 60    -- Monitor performance every minute
	},
	
	-- Admin alert thresholds
	adminAlerts = {
		multipleCriticalThreats = 2,  -- Alert if 2+ critical threats in 1 minute
		rapidThreatIncrease = 5,      -- Alert if 5+ threats in 30 seconds
		systemPerformanceDrop = 0.8   -- Alert if performance drops below 80%
	}
}

-- System state
local systemState = {
	activeBans = {},
	suspiciousPlayers = {},
	threatHistory = {},
	performanceMetrics = {
		threatsDetected = 0,
		bansIssued = 0,
		kicksIssued = 0,
		falsePositives = 0,
		systemUptime = tick()
	},
	adminAlerts = {},
	isInitialized = false
}

-- DataStore for persistent ban records
local BanDataStore = DataStoreService:GetDataStore("AntiExploit_Bans_v1")
local ThreatDataStore = DataStoreService:GetDataStore("AntiExploit_Threats_v1")

-- Initialize AntiExploit system
function AntiExploit.new()
	local self = setmetatable({}, AntiExploit)
	
	-- Dependencies (injected by Service Locator)
	self.securityValidator = nil
	self.logger = nil
	self.adminAlert = nil
	
	-- Initialize security validator
	self.securityValidatorInstance = SecurityValidator.new()
	
	-- Register security event handlers
	self:RegisterSecurityEventHandlers()
	
	-- Initialize monitoring
	self:StartThreatMonitoring()
	
	-- Load persistent ban data
	self:LoadBanData()
	
	systemState.isInitialized = true
	
	return self
end

-- Set dependencies (injected by Service Locator)
function AntiExploit:SetSecurityValidator(validator)
	self.securityValidator = validator
	self.securityValidatorInstance:SetLogger(self.logger)
end

function AntiExploit:SetLogger(logger)
	self.logger = logger
	if self.securityValidatorInstance then
		self.securityValidatorInstance:SetLogger(logger)
	end
end

function AntiExploit:SetAdminAlert(adminAlert)
	self.adminAlert = adminAlert
end

-- Register security event handlers with SecurityValidator
function AntiExploit:RegisterSecurityEventHandlers()
	-- Main threat handler
	self.securityValidatorInstance:RegisterSecurityEventHandler("threatHandler", function(threat)
		self:HandleSecurityThreat(threat)
	end)
	
	-- Action handler for automatic responses
	self.securityValidatorInstance:RegisterSecurityEventHandler("actionHandler", function(player, actionType, threat)
		self:ExecuteSecurityAction(player, actionType, threat)
	end)
end

-- Handle security threats detected by SecurityValidator
function AntiExploit:HandleSecurityThreat(threat)
	local player = Players:GetPlayerByUserId(threat.playerId)
	if not player then return end
	
	-- Record threat in history
	if not systemState.threatHistory[threat.playerId] then
		systemState.threatHistory[threat.playerId] = {}
	end
	table.insert(systemState.threatHistory[threat.playerId], threat)
	
	-- Update performance metrics
	systemState.performanceMetrics.threatsDetected += 1
	
	-- Log threat
	if self.logger then
		self.logger.Warn("AntiExploit", "Security threat detected", {
			player = player.Name,
			threatType = threat.threatType,
			severity = threat.severity,
			evidence = threat.evidence
		})
	end
	
	-- Assess threat level and determine response
	local playerThreatLevel = self:AssessPlayerThreatLevel(player)
	local response = self:DetermineResponse(player, threat, playerThreatLevel)
	
	-- Execute response
	if response then
		self:ExecuteSecurityAction(player, response.action, threat)
	end
	
	-- Check for admin alerts
	self:CheckAdminAlerts(threat)
end

-- Execute security actions (kick, ban, alert)
function AntiExploit:ExecuteSecurityAction(player: Player, actionType: string, threat)
	if not player or not player.Parent then return end
	
	local success, error = pcall(function()
		if actionType == "KICK" then
			self:KickPlayer(player, threat.threatType, threat.description)
			
		elseif actionType == "BAN" then
			local banDuration = self:CalculateBanDuration(player, threat)
			self:BanPlayer(player, threat.threatType, banDuration, threat)
			
		elseif actionType == "ALERT_ADMINS" then
			self:AlertAdmins(player, threat)
			
		elseif actionType == "MONITOR" then
			self:AddToSuspiciousList(player, threat)
			
		else
			if self.logger then
				self.logger.Warn("AntiExploit", "Unknown action type: " .. tostring(actionType))
			end
		end
	end)
	
	if not success and self.logger then
		self.logger.Error("AntiExploit", "Failed to execute security action", {
			actionType = actionType,
			player = player.Name,
			error = error
		})
	end
end

-- Assess player's overall threat level
function AntiExploit:AssessPlayerThreatLevel(player: Player): number
	local threats = systemState.threatHistory[player.UserId]
	if not threats then return 0 end
	
	local currentTime = tick()
	local recentThreats = {}
	
	-- Get threats from last hour
	for _, threat in ipairs(threats) do
		if currentTime - threat.timestamp < 3600 then
			table.insert(recentThreats, threat)
		end
	end
	
	if #recentThreats == 0 then return 0 end
	
	-- Calculate weighted threat level
	local totalThreatLevel = 0
	local criticalCount = 0
	local highCount = 0
	local mediumCount = 0
	
	for _, threat in ipairs(recentThreats) do
		totalThreatLevel += threat.severity
		
		if threat.severity >= 10 then
			criticalCount += 1
		elseif threat.severity >= 8 then
			highCount += 1
		elseif threat.severity >= 5 then
			mediumCount += 1
		end
	end
	
	-- Apply escalation multipliers
	local escalationMultiplier = 1
	if criticalCount >= 2 then escalationMultiplier = 3
	elseif highCount >= 3 then escalationMultiplier = 2
	elseif mediumCount >= 5 then escalationMultiplier = 1.5
	end
	
	return (totalThreatLevel / #recentThreats) * escalationMultiplier
end

-- Determine appropriate response based on threat and player history
function AntiExploit:DetermineResponse(player: Player, threat, playerThreatLevel): {action: string}?
	-- Check if player is already banned
	if self:IsPlayerBanned(player) then
		return nil -- Already banned
	end
	
	-- Get offense count
	local offenseCount = self:GetPlayerOffenseCount(player)
	
	-- Determine response based on threat severity and history
	if threat.severity >= 10 or playerThreatLevel >= 15 then
		-- Critical threat - immediate ban
		return { action = "BAN" }
		
	elseif threat.severity >= 8 or playerThreatLevel >= 12 then
		-- High threat - kick on first offense, ban on repeat
		if offenseCount >= 1 then
			return { action = "BAN" }
		else
			return { action = "KICK" }
		end
		
	elseif threat.severity >= 5 or playerThreatLevel >= 8 then
		-- Medium threat - monitor and alert admins
		return { action = "ALERT_ADMINS" }
		
	else
		-- Low threat - just monitor
		return { action = "MONITOR" }
	end
end

-- Kick player with detailed reason
function AntiExploit:KickPlayer(player: Player, reason: string, details: string)
	local kickMessage = string.format(
		"🚫 SECURITY VIOLATION DETECTED 🚫\n\nReason: %s\nDetails: %s\n\nIf you believe this is an error, please contact an administrator.",
		reason,
		details
	)
	
	-- Log kick
	if self.logger then
		self.logger.Info("AntiExploit", "Player kicked for security violation", {
			player = player.Name,
			userId = player.UserId,
			reason = reason,
			details = details
		})
	end
	
	-- Update metrics
	systemState.performanceMetrics.kicksIssued += 1
	
	-- Execute kick
	player:Kick(kickMessage)
end

-- Ban player with specified duration and reason
function AntiExploit:BanPlayer(player: Player, reason: string, banDuration: number?, threat)
	local banRecord: BanRecord = {
		userId = player.UserId,
		username = player.Name,
		reason = reason,
		banDate = tick(),
		banLength = banDuration,
		evidence = threat.evidence or {},
		adminUserId = nil -- Automatic ban
	}
	
	-- Store ban locally
	systemState.activeBans[player.UserId] = banRecord
	
	-- Save ban to DataStore
	self:SaveBanToDataStore(banRecord)
	
	-- Log ban
	if self.logger then
		self.logger.Warn("AntiExploit", "Player banned for security violation", {
			player = player.Name,
			userId = player.UserId,
			reason = reason,
			duration = banDuration and (banDuration .. " hours") or "permanent",
			evidence = banRecord.evidence
		})
	end
	
	-- Update metrics
	systemState.performanceMetrics.bansIssued += 1
	
	-- Create kick message
	local banMessage = string.format(
		"🔒 ACCOUNT TEMPORARILY BANNED 🔒\n\nReason: %s\nBan Duration: %s\n\nYour account has been automatically banned due to detected security violations.\nIf you believe this is an error, please contact an administrator.\n\nBan ID: %s",
		reason,
		banDuration and (banDuration .. " hours") or "Permanent",
		HttpService:GenerateGUID(false)
	)
	
	-- Execute ban (kick with ban message)
	player:Kick(banMessage)
end

-- Calculate ban duration based on offense history
function AntiExploit:CalculateBanDuration(player: Player, threat): number?
	local offenseCount = self:GetPlayerOffenseCount(player)
	
	-- Permanent ban for critical exploits
	if threat.severity >= 10 and threat.threatType == "TELEPORT_EXPLOIT" then
		return nil -- Permanent
	end
	
	-- Progressive ban durations
	if offenseCount == 0 then
		return ANTI_EXPLOIT_CONFIG.banDurations.FIRST_OFFENSE
	elseif offenseCount == 1 then
		return ANTI_EXPLOIT_CONFIG.banDurations.SECOND_OFFENSE
	elseif offenseCount == 2 then
		return ANTI_EXPLOIT_CONFIG.banDurations.THIRD_OFFENSE
	else
		return nil -- Permanent ban for repeat offenders
	end
end

-- Get player's offense count from DataStore
function AntiExploit:GetPlayerOffenseCount(player: Player): number
	local success, offenseData = pcall(function()
		return ThreatDataStore:GetAsync("offenses_" .. player.UserId)
	end)
	
	if success and offenseData then
		return offenseData.count or 0
	end
	
	return 0
end

-- Alert administrators about security threats
function AntiExploit:AlertAdmins(player: Player, threat)
	if not self.adminAlert then
		if self.logger then
			self.logger.Warn("AntiExploit", "AdminAlert service not available for threat notification")
		end
		return
	end
	
	local alertMessage = string.format(
		"🚨 SECURITY ALERT 🚨\n\nPlayer: %s (ID: %s)\nThreat: %s\nSeverity: %s/10\nTime: %s",
		player.Name,
		player.UserId,
		threat.threatType,
		threat.severity,
		os.date("%H:%M:%S", threat.timestamp)
	)
	
	-- Send alert through AdminAlert service
	self.adminAlert:SendAlert("SECURITY_THREAT", alertMessage, {
		playerId = player.UserId,
		threatType = threat.threatType,
		severity = threat.severity,
		evidence = threat.evidence
	})
end

-- Add player to suspicious activity monitoring
function AntiExploit:AddToSuspiciousList(player: Player, threat)
	if not systemState.suspiciousPlayers[player.UserId] then
		systemState.suspiciousPlayers[player.UserId] = {
			playerId = player.UserId,
			playerName = player.Name,
			suspiciousActivities = {},
			monitoringStartTime = tick(),
			totalThreatLevel = 0
		}
	end
	
	local suspiciousData = systemState.suspiciousPlayers[player.UserId]
	table.insert(suspiciousData.suspiciousActivities, {
		activityType = threat.threatType,
		timestamp = threat.timestamp,
		severity = threat.severity,
		details = threat.evidence
	})
	
	suspiciousData.totalThreatLevel += threat.severity
	
	if self.logger then
		self.logger.Info("AntiExploit", "Player added to suspicious activity monitoring", {
			player = player.Name,
			threatType = threat.threatType,
			totalThreatLevel = suspiciousData.totalThreatLevel
		})
	end
end

-- Check if player is currently banned
function AntiExploit:IsPlayerBanned(player: Player): boolean
	local banRecord = systemState.activeBans[player.UserId]
	if not banRecord then return false end
	
	-- Check if ban has expired
	if banRecord.banLength then
		local banExpiry = banRecord.banDate + (banRecord.banLength * 3600) -- Convert hours to seconds
		if tick() > banExpiry then
			-- Ban expired, remove it
			systemState.activeBans[player.UserId] = nil
			self:RemoveBanFromDataStore(player.UserId)
			return false
		end
	end
	
	return true
end

-- Load ban data from DataStore on startup
function AntiExploit:LoadBanData()
	task.spawn(function()
		local success, banData = pcall(function()
			return BanDataStore:GetAsync("active_bans")
		end)
		
		if success and banData then
			-- Verify bans are still valid and load them
			for userId, banRecord in pairs(banData) do
				if banRecord.banLength then
					local banExpiry = banRecord.banDate + (banRecord.banLength * 3600)
					if tick() <= banExpiry then
						systemState.activeBans[userId] = banRecord
					end
				else
					-- Permanent ban
					systemState.activeBans[userId] = banRecord
				end
			end
			
			if self.logger then
				self.logger.Info("AntiExploit", "Loaded active bans from DataStore", {
					activeBanCount = #systemState.activeBans
				})
			end
		end
	end)
end

-- Save ban to DataStore
function AntiExploit:SaveBanToDataStore(banRecord: BanRecord)
	task.spawn(function()
		local success, error = pcall(function()
			-- Update active bans list
			local activeBans = BanDataStore:GetAsync("active_bans") or {}
			activeBans[banRecord.userId] = banRecord
			BanDataStore:SetAsync("active_bans", activeBans)
			
			-- Save individual ban record
			BanDataStore:SetAsync("ban_" .. banRecord.userId .. "_" .. banRecord.banDate, banRecord)
			
			-- Update offense count
			local offenseData = ThreatDataStore:GetAsync("offenses_" .. banRecord.userId) or { count = 0 }
			offenseData.count += 1
			ThreatDataStore:SetAsync("offenses_" .. banRecord.userId, offenseData)
		end)
		
		if not success and self.logger then
			self.logger.Error("AntiExploit", "Failed to save ban to DataStore", {
				userId = banRecord.userId,
				error = error
			})
		end
	end)
end

-- Remove ban from DataStore
function AntiExploit:RemoveBanFromDataStore(userId: number)
	task.spawn(function()
		local success, error = pcall(function()
			local activeBans = BanDataStore:GetAsync("active_bans") or {}
			activeBans[userId] = nil
			BanDataStore:SetAsync("active_bans", activeBans)
		end)
		
		if not success and self.logger then
			self.logger.Error("AntiExploit", "Failed to remove ban from DataStore", {
				userId = userId,
				error = error
			})
		end
	end)
end

-- Start continuous threat monitoring
function AntiExploit:StartThreatMonitoring()
	-- Threat assessment loop
	task.spawn(function()
		while systemState.isInitialized do
			task.wait(ANTI_EXPLOIT_CONFIG.monitoringIntervals.threatAssessment)
			self:PerformThreatAssessment()
		end
	end)
	
	-- Ban data synchronization loop
	task.spawn(function()
		while systemState.isInitialized do
			task.wait(ANTI_EXPLOIT_CONFIG.monitoringIntervals.banDataSync)
			self:SynchronizeBanData()
		end
	end)
	
	-- Performance monitoring loop
	task.spawn(function()
		while systemState.isInitialized do
			task.wait(ANTI_EXPLOIT_CONFIG.monitoringIntervals.performanceMonitoring)
			self:MonitorPerformance()
		end
	end)
end

-- Perform threat assessment on all players
function AntiExploit:PerformThreatAssessment()
	for _, player in pairs(Players:GetPlayers()) do
		local threatLevel = self:AssessPlayerThreatLevel(player)
		
		-- Auto-ban for excessive threats
		if threatLevel >= 20 then
			local mockThreat = {
				playerId = player.UserId,
				threatType = "ACCUMULATED_VIOLATIONS",
				severity = 10,
				description = "Multiple security violations detected",
				timestamp = tick(),
				evidence = { accumulatedThreatLevel = threatLevel }
			}
			
			self:ExecuteSecurityAction(player, "BAN", mockThreat)
		end
	end
end

-- Synchronize ban data with DataStore
function AntiExploit:SynchronizeBanData()
	-- This ensures ban data stays consistent across server instances
	self:LoadBanData()
end

-- Monitor system performance
function AntiExploit:MonitorPerformance()
	local metrics = systemState.performanceMetrics
	metrics.systemUptime = tick() - metrics.systemUptime
	
	-- Log performance metrics
	if self.logger then
		self.logger.Info("AntiExploit", "Performance metrics", metrics)
	end
end

-- Check for conditions that require admin alerts
function AntiExploit:CheckAdminAlerts(threat)
	local currentTime = tick()
	
	-- Count recent critical threats
	local recentCriticalThreats = 0
	for _, playerThreats in pairs(systemState.threatHistory) do
		for _, historicalThreat in ipairs(playerThreats) do
			if currentTime - historicalThreat.timestamp < 60 and historicalThreat.severity >= 10 then
				recentCriticalThreats += 1
			end
		end
	end
	
	-- Alert if multiple critical threats detected
	if recentCriticalThreats >= ANTI_EXPLOIT_CONFIG.adminAlerts.multipleCriticalThreats then
		if self.adminAlert then
			self.adminAlert:SendAlert("MULTIPLE_CRITICAL_THREATS", 
				string.format("⚠️ %d critical threats detected in the last minute!", recentCriticalThreats),
				{ criticalThreatCount = recentCriticalThreats }
			)
		end
	end
end

-- Get comprehensive security metrics
function AntiExploit:GetSecurityMetrics(): {[string]: any}
	return {
		systemMetrics = systemState.performanceMetrics,
		activeBans = #systemState.activeBans,
		suspiciousPlayers = #systemState.suspiciousPlayers,
		threatHistory = self:GetThreatHistorySummary(),
		validationMetrics = self.securityValidatorInstance and self.securityValidatorInstance:GetSecurityMetrics() or {}
	}
end

-- Get threat history summary
function AntiExploit:GetThreatHistorySummary(): {[string]: any}
	local summary = {
		totalThreats = 0,
		threatsByType = {},
		threatsBySeverity = {},
		recentThreats = 0
	}
	
	local currentTime = tick()
	
	for _, playerThreats in pairs(systemState.threatHistory) do
		for _, threat in ipairs(playerThreats) do
			summary.totalThreats += 1
			
			-- Count by type
			summary.threatsByType[threat.threatType] = (summary.threatsByType[threat.threatType] or 0) + 1
			
			-- Count by severity
			local severityLevel = "LOW"
			if threat.severity >= 10 then severityLevel = "CRITICAL"
			elseif threat.severity >= 8 then severityLevel = "HIGH"
			elseif threat.severity >= 5 then severityLevel = "MEDIUM"
			end
			
			summary.threatsBySeverity[severityLevel] = (summary.threatsBySeverity[severityLevel] or 0) + 1
			
			-- Count recent threats (last hour)
			if currentTime - threat.timestamp < 3600 then
				summary.recentThreats += 1
			end
		end
	end
	
	return summary
end

-- Handle player joining (check for bans)
function AntiExploit:HandlePlayerJoining(player: Player)
	-- Check if player is banned
	if self:IsPlayerBanned(player) then
		local banRecord = systemState.activeBans[player.UserId]
		local timeRemaining = "Unknown"
		
		if banRecord.banLength then
			local banExpiry = banRecord.banDate + (banRecord.banLength * 3600)
			local remaining = banExpiry - tick()
			timeRemaining = string.format("%.1f hours", remaining / 3600)
		else
			timeRemaining = "Permanent"
		end
		
		local banMessage = string.format(
			"🔒 ACCOUNT BANNED 🔒\n\nReason: %s\nTime Remaining: %s\n\nYour account is currently banned.\nIf you believe this is an error, please contact an administrator.",
			banRecord.reason,
			timeRemaining
		)
		
		-- Log ban enforcement
		if self.logger then
			self.logger.Info("AntiExploit", "Banned player attempted to join", {
				player = player.Name,
				userId = player.UserId,
				banReason = banRecord.reason,
				timeRemaining = timeRemaining
			})
		end
		
		-- Kick immediately
		player:Kick(banMessage)
		return
	end
	
	-- Initialize clean tracking for new player
	if self.logger then
		self.logger.Info("AntiExploit", "Player joined - security monitoring active", {
			player = player.Name,
			userId = player.UserId
		})
	end
end

-- Validate RemoteEvent call using SecurityValidator
function AntiExploit:ValidateRemoteEventCall(player: Player, remoteName: string, schema, ...): (boolean, {any}?)
	if not self.securityValidatorInstance then
		if self.logger then
			self.logger.Error("AntiExploit", "SecurityValidator not initialized")
		end
		return false, nil
	end
	
	local data = {...}
	local result = self.securityValidatorInstance:ValidateRemoteCall(player, remoteName, schema, data)
	
	if result.isValid then
		return true, result.sanitizedData
	else
		-- Log validation failure
		if self.logger then
			self.logger.Warn("AntiExploit", "RemoteEvent validation failed", {
				player = player.Name,
				remoteName = remoteName,
				errors = result.errors
			})
		end
		
		return false, nil
	end
end

-- Initialize the system
function AntiExploit:Initialize()
	if systemState.isInitialized then
		if self.logger then
			self.logger.Warn("AntiExploit", "System already initialized")
		end
		return
	end
	
	-- Connect player events
	Players.PlayerAdded:Connect(function(player)
		self:HandlePlayerJoining(player)
	end)
	
	-- Handle players already in game
	for _, player in pairs(Players:GetPlayers()) do
		self:HandlePlayerJoining(player)
	end
	
	systemState.isInitialized = true
	
	if self.logger then
		self.logger.Info("AntiExploit", "Enterprise Anti-Exploit system initialized", {
			systemUptime = systemState.performanceMetrics.systemUptime,
			monitoringIntervals = ANTI_EXPLOIT_CONFIG.monitoringIntervals
		})
	end
end

return AntiExploit
